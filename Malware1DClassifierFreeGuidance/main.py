import numpy as np
from torch.utils.data import Dataset, DataLoader
import EmberHistogramLoader
import HistogramEvaluation
from DiffusionModel import Unet1D, GaussianDiffusion1D
import torch
from torch.optim import Adam
from torch import Tensor
import json
import sys
import joblib
import os
class DataSetTest(Dataset):

    def __init__(self, tensor: Tensor, labels):
        self.tensor = tensor.clone()
        self.labels = labels
    def __len__(self):
        return len(self.tensor)

    def __getitem__(self, idx):
        img = self.tensor[idx]
        label = self.labels[idx]

        return img, label

if __name__ == '__main__':
    num_classes = 2
    channels = 1
    batch_size = 256
    dim = int(sys.argv[1]) if len(sys.argv) >= 2 else 64
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    #train_histograms, train_labels = EmberHistogramLoader.LoadDatasetFromFolder("C:/Users/40237845/Documents/Ember_2017/ember_2017_2/train")
    #train_histograms, train_labels = EmberHistogramLoader.LoadDatasetFromFile("C:/Users/40237845/Documents/Ember_2017/ember_2017_2/test_features.jsonl")
    #test_histograms, test_labels = EmberHistogramLoader.LoadDatasetFromFile("C:/Users/40237845/Documents/Ember_2017/ember_2017_2/test_features.jsonl")
    train_histograms, train_labels = EmberHistogramLoader.LoadDatasetFromFolderWithBenignAndFamilies("C:/Users/40237845/Documents/Ember_2018/train")
    test_histograms, test_labels = EmberHistogramLoader.LoadDatasetFromFileWithBenignAndFamilies("C:/Users/40237845/Documents/Ember_2018/test_features.jsonl")
    #test_histograms, test_labels = train_histograms, train_labels
    train_dataset = DataSetTest(train_histograms, train_labels)
    test_dataset = DataSetTest(test_histograms, test_labels)

    dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    dataloader_val = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

    model = Unet1D(
        dim = dim,
        channels=1,
        dim_mults = (1, 2, 4),
        num_classes = num_classes,
        cond_drop_prob = 0.5
    )

    diffusion = GaussianDiffusion1D(
        model,
        seq_length = 256,
        timesteps = 1000,
        auto_normalize=False
    ).cuda()

    optimizer = Adam(model.parameters(), lr=5e-4)

    def train():

        epochs = 50

        train_loss = 0
        train_iters = 0

        loss_history = {}

        for epoch in range(epochs):
            for step, batch in enumerate(dataloader):
                optimizer.zero_grad()

                batch_size = batch[0].shape[0]
                labels = batch[1].to(device)
                batch = batch[0].to(device)

                loss = diffusion(batch, classes=labels)
                train_loss += loss.item()
                train_iters += 1

                loss.backward()
                optimizer.step()

                if step % 250 == 0:
                    val_loss = 0
                    val_iters = 0
                    with torch.no_grad():
                        for _, val_batch in enumerate(dataloader_val):
                            val_batch_size = val_batch[0].shape[0]
                            val_labels = val_batch[1].to(device)
                            val_batch = val_batch[0].to(device)
                            val_loss += diffusion(val_batch, classes=val_labels).item()
                            val_iters += 1
                        print("Epoch:", epoch, " Loss:", train_loss / train_iters, " Val Loss:", val_loss / val_iters)
                    train_loss = 0
                    train_iters = 0
                torch.save(model.state_dict(), f"./results/model{epoch}.pt")
            loss_history[epoch] = {"train_loss": train_loss / train_iters, "validation_loss": val_loss / val_iters}

        json.dump(loss_history, open(f"./Loss Histories/loss_history{dim}.json", "w"))

    train()
    #model.load_state_dict(torch.load("./results/model49.pt"))
    malware_samples = diffusion.sample(
        classes=torch.IntTensor(np.ones(1000)).cuda(),
        cond_scale=7.
    )

    malware_samples = malware_samples.cpu().numpy().squeeze(1)

    LGBMModel = joblib.load(f"{os.getcwd()}/MalwareFamilyLGBMV2.pkl")
    #HistogramEvaluation.AssessHistogramQualityWithFamilies(LGBMModel, malware_samples, dim)
    predictions = LGBMModel.predict(malware_samples)
    print(f"Predicted malware families are: {predictions}")
